<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>NNLWP - trainer</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }

    html {
      height: 100%;
    }

    body {
      font-family: "San Francisco", "Segoe UI", sans-serif;
      font-size: 15px;
      padding: 30px 0;
      margin: 0;
      height: 100%;
      display: flex;
      justify-content: center;
      background-color: #333;
      color: hsl(60, 55%, 93%);
    }

    main {
      width: 100%;
      max-width: 900px;
      padding: 20px;
      height: 100%;
      overflow-y: auto;
      background-color: #444;
    }

    header {
      background-color: #505050;
      padding: 10px;
      margin-bottom: 30px;
    }

    article {
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }

    h1 {
      font-size: 18px;
      font-weight: bold;
    }

    a {
      text-decoration: none;
      color: hsl(213, 80%, 76%);
      cursor: pointer;
    }

    a.inactive {
      color: inherit;
      cursor: default;
      color: #aaa;
    }

    span.success {
      color: hsl(132, 60%, 60%);
    }

    span.error {
      color: hsl(354, 70%, 60%);
    }
  </style>
</head>
<body>
<script>

  let elmOut;
  let trainStruct, testStruct;
  let trainX, trainY;
  let testX, testY;
  let cceWeights;
  let model;

  const fnTrain = "hu-train.json";
  const fnTest = "hu-test.json";

  document.addEventListener("DOMContentLoaded", () => {
    elmOut = document.getElementsByTagName("article")[0];
    document.getElementById("fn-train").innerText = fnTrain;
    document.getElementById("fn-test").innerText = fnTest;
    document.getElementById("start").addEventListener("click", step10);
  });

  window.onerror = (message, source, lineno, colno, error) => {
    let summary = "Unexpected error\nFile: " + source + "\nPosition: Line " + lineno + " Column " + colno;
    log(summary, "error");
    log(message, "error");
    log(error.stack, "error");
  };

  window.onunhandledrejection = (event) => {
    log("Unexpected error: unhandled rejection in promise:", "error");
    log(event.reason, "error");
  }

  function log(line, category) {
    let elm = document.createElement("span");
    elm.innerText = line + "\n";
    if (category) elm.classList.add(category);
    elmOut.appendChild(elm);
    elmOut.scrollIntoView(false);
  }

  async function step10() {
    elmOut.innerText = "";

    log("Fetching data");
    let response = await fetch(fnTrain);
    trainStruct = await response.json();
    response = await fetch(fnTest);
    testStruct = await response.json();

    const inputFields = ["pres3", "pres2", "pres1", "pres0"];

    let catSums = [0, 0, 0, 0];
    [testX, testY] = structToData(trainStruct, inputFields, catSums);
    catSums = [0, 0, 0, 0];
    [trainX, trainY] = structToData(trainStruct, inputFields, catSums);
    let allCatSums = 0;
    for (let i = 0; i < catSums.length; ++i) catSums[i] = Math.pow(catSums[i], -0.5);
    for (const cs of catSums) allCatSums += cs;
    for (let i = 0; i < catSums.length; ++i) catSums[i] /= allCatSums;
    cceWeights = tf.tensor(catSums);
    console.log(catSums);

    step20();

    function structToData(struct, xFieldNames, catSums) {
      let xs = [], ys = [];

      for (const itm of struct) {

        let xVals = [];
        for (const fname of xFieldNames) {
          xVals.push(Number.parseFloat(itm.input[fname]));
        }
        xs.push(xVals);

        // ys.push(Number.parseFloat(itm.output.precipMM));

        let yVals = [0, 0, 0, 0];
        if (itm.output.precip == "None") yVals[0] = 1;
        else if (itm.output.precip == "Light") yVals[1] = 1;
        else if (itm.output.precip == "Medium") yVals[2] = 1;
        else if (itm.output.precip == "Heavy") yVals[3] = 1;
        for (let i = 0; i < yVals.length; ++i) catSums[i] += yVals[i];

        // let yVals = [0, 0, 0, 0, 0, 0, 0, 0];
        // if (itm.output.precip == "None") yVals[0] = 1;
        // else if (itm.output.precip == "Light") yVals[1] = 1;
        // else if (itm.output.precip == "Medium") yVals[2] = 1;
        // else if (itm.output.precip == "Heavy") yVals[3] = 1;
        // if (itm.output.cloud == "None") yVals[4] = 1;
        // else if (itm.output.cloud == "Light") yVals[5] = 1;
        // else if (itm.output.cloud == "Medium") yVals[6] = 1;
        // else if (itm.output.cloud == "Full") yVals[7] = 1;

        // let yVals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        // if (itm.output.category == "Clear") yVals[0] = 1;
        // else if (itm.output.category == "FewCloudsDry") yVals[1] = 1;
        // else if (itm.output.category == "FewCloudsLittlePrecip") yVals[2] = 1;
        // else if (itm.output.category == "ManyCloudsDry") yVals[3] = 1;
        // else if (itm.output.category == "ManyCloudsLittlePrecip") yVals[4] = 1;
        // else if (itm.output.category == "ManyCloudsMediumPrecip") yVals[5] = 1;
        // else if (itm.output.category == "OvercastDry") yVals[6] = 1;
        // else if (itm.output.category == "OvercastLittlePrecip") yVals[7] = 1;
        // else if (itm.output.category == "OvercastMediumPrecip") yVals[8] = 1;
        // else if (itm.output.category == "OvercastHeavyPrecip") yVals[9] = 1;
        // else if (itm.output.category == "ExtremePrecip") yVals[10] = 1;
        // else throw "Unexpected category: " + itm.output.category;

        ys.push(yVals);
      }
      return [xs, ys];
    }
  }

  async function step20() {

    model = tf.sequential()

    model.add(tf.layers.dense({
      inputShape: [trainX[0].length],
      units: 48,
      activation: "sigmoid",
    }));
    model.add(tf.layers.dense({
      units: 48,
      activation: "sigmoid",
    }));
    model.add(tf.layers.dense({
      units: trainY[0].length,
      activation: "softmax",
    }));
    // model.add(tf.layers.dense({
    //   units: 1,
    //   activation: "sigmoid",
    // }));

    // https://js.tensorflow.org/api/latest/#Training-Losses
    // https://js.tensorflow.org/api/latest/#Metrics
    const config = {
      optimizer: tf.train.adam(0.01),
      // loss: tf.losses.meanSquaredError,
      // metrics: [tf.metrics.meanSquaredError],
      loss: categoricalCrossentropyWeighted,
      metrics: ['accuracy'],
    };
    model.compile(config);

    const trainOpt = {
      shuffle: false,
      epochs: 2,
      batchSize: 16,
      validationData: [tf.tensor(testX), tf.tensor(testY)],
      callbacks: {onEpochEnd, onBatchEnd},
    };

    let tInput = tf.tensor(trainX);
    let tResults = tf.tensor(trainY);
    await model.fit(tInput, tResults, trainOpt);

    step30();
  }

  function categoricalCrossentropyWeighted(target, output, fromLogits = false) {
    return tf.tidy(() => {
      if (fromLogits) {
        output = tf.softmax(output);
      } else {
        // scale preds so that the class probabilities of each sample sum to 1.
        const outputSum = tf.sum(output, output.shape.length - 1, true);
        output = tf.div(output, outputSum);
      }
      output = tf.clipByValue(output, 0.000001, 1 - 0.000001);
      return tf.neg(tf.sum(
          tf.mul(tf.mul(target.toFloat(), tf.log(output)), cceWeights),
        output.shape.length - 1));
    });
  }


  function onBatchEnd(ix, logs) {
    if (ix % 100 != 0) return;
    console.log('Batch end', ix, logs);
  }

  function onEpochEnd(ix, logs) {
    console.log('Epoch end', ix, logs);
  }

  async function step30() {

    let nCorrect = 0;
    let nTotal = 100;
    for (let i = 0; i < nTotal; ++i) {

      let res = model.predict(tf.tensor(trainX[i]).expandDims());
      res = res.dataSync();

      let trainHotIx = findMaxIx(trainY[i]);
      let predHotIx = findMaxIx(res);
      if (trainHotIx == predHotIx) ++nCorrect;
      console.log("Truth/Pred: " + trainHotIx + " / " + predHotIx);

      // console.log("Truth/Pred: " + trainY[i] + " / " + res);
    }
    console.log(nCorrect + " correct of " + nTotal + " (" + (nCorrect * 100 / nTotal).toFixed(2) + "%)");

    function findMaxIx(vals) {
      let max = Number.MIN_VALUE;
      let res = -1;
      for (let i = 0; i < vals.length; ++i) {
        if (vals[i] > max) {
          max = vals[i];
          res = i;
        }
      }
      return res;
    }

    step40();
  }

  async function step40() {
    let dump = "layers " + 2 * model.layers.length + "\n";
    for (let i = 0; i < model.layers.length; ++i) {

      let layer = model.layers[i];
      dump += "layer " + (2 * i) + " " + layer.getClassName() + "\n"

      let weights = await layer.getWeights()[0].data();
      let nInputs = weights.length / layer.units;
      dump += nInputs + " " + layer.units + "\n";

      for (let j = 0; j < nInputs; ++j) {
        dump += "[ ";
        for (let k = 0; k < layer.units; ++k) {
          dump += " " + weights[j * layer.units + k] + " ";
        }
        dump += "]\n";
      }

      let biases = await layer.getWeights()[1].data();
      dump += "[ ";
      for (let j = 0; j < layer.units; ++j) {
        dump += " " + biases[j] + " ";
      }
      dump += "]\n";

      dump += "layer " + (2 * i + 1) + " Activation\n";
      dump += layer.activation.getClassName() + "\n";
    }
    // console.log(dump);
  }

</script>
<main>
  <header>
    <h1>Neural Network Local Weather Predictor</h1>
    <p>
      <b>Training set: </b><span id="fn-train"></span><br>
      <b>Test set: </b><span id="fn-test"></span>
    </p>
    <p>
      <i>^^ edit these manually in the script</i>
    </p>
    <hr>
    <p>
      <button id="start">Start</button>
      <a id="download" class="inactive">Download result</a>
    </p>
  </header>
  <article></article>
</main>
</body>
</html>